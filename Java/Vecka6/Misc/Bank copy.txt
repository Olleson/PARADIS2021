// Peter Idestam-Almquist, 2020-01-31.
// Olivia Aixinjuelo, 2020-03-

// package paradis.assignment2;
package Java.Vecka6;

import java.util.List;
import java.util.Random;
import java.util.ArrayList;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class Bank {
	// Instance variables.
	private final List<Account> accounts = new ArrayList<Account>();
	private final List<ReentrantReadWriteLock> locks = new ArrayList<ReentrantReadWriteLock>();

	private final Random random = new Random();

	// Instance methods.
	int newAccount(int balance) {
		synchronized (this) {
			int accountId = accounts.size(); // FIX ORIGINAL
			accounts.add(new Account(accountId, balance));
			locks.add(new ReentrantReadWriteLock(true));
			return accountId;
		}
	}

	int getAccountBalance(int accountId) {
		ReadWriteLock lock = locks.get(accountId);
		Account account = accounts.get(accountId);
		// lock.readLock().lock();
		// try {
		// return account.getBalance();
		// } finally {
		// lock.readLock().unlock();
		// }

		for (int i = 0; i < 100; i++) {
			if (lock.readLock().tryLock()) {
				try {
					System.out.println("could get lock");
					return account.getBalance();
				} finally {
					lock.readLock().unlock();
				}
			}
			try {
				Thread.sleep(random.nextInt(50));
			} catch (InterruptedException E) {
				System.out.println(E);
			}
		}
		System.out.println("i should only print if i never got the readlock lol");
		return account.getBalance();
	}

	void runOperation(Operation operation) {
		int ID = operation.getAccountId();
		ReadWriteLock lock = locks.get(ID);
		Account account = accounts.get(ID);
		for (int i = 0; i < 100; i++) {
			if (lock.writeLock().tryLock()) {
				try {
					System.out.println(Thread.currentThread().getName() + " changing balance");
					int balance = account.getBalance();
					balance = balance + operation.getAmount();
					account.setBalance(balance);
					return;
				} finally {
					lock.writeLock().unlock();
				}
			}
			try {
				//System.out.println(Thread.currentThread().getName() + " sleeping & retrying operation...");
				Thread.sleep(random.nextInt(50));
			} catch (InterruptedException E) {
				System.out.println(E);
			}
		}
		System.out.println(Thread.currentThread().getName() + " failed to do operation after 100 tries");
	}

	// Go through all locks, if a Transaction is unable to get all the keys then
	// return false
	boolean checkLocks(List<Operation> operations) {
		boolean valid = false;
		for (int i = 0; i < 100; i++) {
			for (Operation op : operations) {
				ReadWriteLock lock = locks.get(op.getAccountId());
				valid = lock.writeLock().tryLock() ? true : false;
			}
			try {
				Thread.sleep(random.nextInt(50));
			} catch (InterruptedException e) {
				System.out.println(e);
			}
		}
		return valid;
		// for (int i = 0; i < 100; i++) {
		// 	for (Operation operation : operations) {
		// 		ReadWriteLock lock = locks.get(operation.getAccountId());
		// 		if (!lock.writeLock().tryLock()) {
		// 			// System.out.println(Thread.currentThread().getName() + " is unable to obtain
		// 			// writelock");
		// 			return false;
		// 		}
		// 	}
		// 	try {
		// 		System.out.println(Thread.currentThread().getName() + " sleeping and retrying");
		// 		// System.out.println(Thread.currentThread().getName() + " sleeping and retrying
		// 		// w/ unlock");
		// 		Thread.sleep(random.nextInt(50));
		// 	} catch (InterruptedException e) {
		// 		System.out.println(e);
		// 	}
		// }
		// System.out.println(Thread.currentThread().getName() + " obtained all locks!");
		// return true;
	}

	void runTransaction(Transaction transaction) {
		List<Operation> currentOperations = transaction.getOperations();
		if (!checkLocks(currentOperations)) {
			System.out.println(Thread.currentThread().getName() + " aborting Transaction.");
			for (Operation operation : currentOperations) {
				if (locks.get(operation.getAccountId()).writeLock().isHeldByCurrentThread()) {
					locks.get(operation.getAccountId()).writeLock().unlock();
				}
			}
			return;
		}
		for (Operation operation : currentOperations) {
			int ID = operation.getAccountId();
			ReadWriteLock lock = locks.get(ID);
			try {
				//System.out.println(Thread.currentThread().getName() + " runOperation();");
				runOperation(operation);
			} finally {
				lock.writeLock().unlock();
				//System.out.println(Thread.currentThread().getName() + " unlocking after runOperation();");
			}
		}
	}

	// Old stuff for the E
	// void runTransaction(Transaction transaction) {
	// List<Operation> currentOperations = transaction.getOperations();
	// for (Operation operation : currentOperations) {
	// int ID = operation.getAccountId();
	// ReadWriteLock lock = locks.get(ID);
	// lock.writeLock().lock();
	// try {
	// runOperation(operation);
	// } finally {
	// lock.writeLock().unlock();
	// }
	// }
	// }

	// void runOperation(Operation operation) {
	// int ID = operation.getAccountId();
	// ReadWriteLock lock = locks.get(ID);
	// lock.writeLock().lock();
	// try {
	// Account account = accounts.get(ID);
	// int balance = account.getBalance();
	// balance = balance + operation.getAmount();
	// account.setBalance(balance);
	// } finally {
	// lock.writeLock().unlock();
	// }
	// }
}
